// Code generated by MockGen. DO NOT EDIT.
// Source: ./internal/microservices/authorization/proto/authorization_grpc.pb.go

// Package usecase is a generated GoMock package.
package usecase

import (
	context "context"
	proto "myapp/internal/microservices/authorization/proto"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	grpc "google.golang.org/grpc"
)

// MockAuthorizationClient is a mock of AuthorizationClient interface.
type MockAuthorizationClient struct {
	ctrl     *gomock.Controller
	recorder *MockAuthorizationClientMockRecorder
}

// MockAuthorizationClientMockRecorder is the mock recorder for MockAuthorizationClient.
type MockAuthorizationClientMockRecorder struct {
	mock *MockAuthorizationClient
}

// NewMockAuthorizationClient creates a new mock instance.
func NewMockAuthorizationClient(ctrl *gomock.Controller) *MockAuthorizationClient {
	mock := &MockAuthorizationClient{ctrl: ctrl}
	mock.recorder = &MockAuthorizationClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAuthorizationClient) EXPECT() *MockAuthorizationClientMockRecorder {
	return m.recorder
}

// CheckAuthorization mocks base method.
func (m *MockAuthorizationClient) CheckAuthorization(ctx context.Context, in *proto.Cookie, opts ...grpc.CallOption) (*proto.UserID, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CheckAuthorization", varargs...)
	ret0, _ := ret[0].(*proto.UserID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CheckAuthorization indicates an expected call of CheckAuthorization.
func (mr *MockAuthorizationClientMockRecorder) CheckAuthorization(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckAuthorization", reflect.TypeOf((*MockAuthorizationClient)(nil).CheckAuthorization), varargs...)
}

// LogIn mocks base method.
func (m *MockAuthorizationClient) LogIn(ctx context.Context, in *proto.LogInData, opts ...grpc.CallOption) (*proto.Cookie, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LogIn", varargs...)
	ret0, _ := ret[0].(*proto.Cookie)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LogIn indicates an expected call of LogIn.
func (mr *MockAuthorizationClientMockRecorder) LogIn(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LogIn", reflect.TypeOf((*MockAuthorizationClient)(nil).LogIn), varargs...)
}

// LogOut mocks base method.
func (m *MockAuthorizationClient) LogOut(ctx context.Context, in *proto.Cookie, opts ...grpc.CallOption) (*proto.Empty, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LogOut", varargs...)
	ret0, _ := ret[0].(*proto.Empty)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LogOut indicates an expected call of LogOut.
func (mr *MockAuthorizationClientMockRecorder) LogOut(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LogOut", reflect.TypeOf((*MockAuthorizationClient)(nil).LogOut), varargs...)
}

// SignUp mocks base method.
func (m *MockAuthorizationClient) SignUp(ctx context.Context, in *proto.SignUpData, opts ...grpc.CallOption) (*proto.Cookie, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SignUp", varargs...)
	ret0, _ := ret[0].(*proto.Cookie)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SignUp indicates an expected call of SignUp.
func (mr *MockAuthorizationClientMockRecorder) SignUp(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SignUp", reflect.TypeOf((*MockAuthorizationClient)(nil).SignUp), varargs...)
}

// MockAuthorizationServer is a mock of AuthorizationServer interface.
type MockAuthorizationServer struct {
	ctrl     *gomock.Controller
	recorder *MockAuthorizationServerMockRecorder
}

// MockAuthorizationServerMockRecorder is the mock recorder for MockAuthorizationServer.
type MockAuthorizationServerMockRecorder struct {
	mock *MockAuthorizationServer
}

// NewMockAuthorizationServer creates a new mock instance.
func NewMockAuthorizationServer(ctrl *gomock.Controller) *MockAuthorizationServer {
	mock := &MockAuthorizationServer{ctrl: ctrl}
	mock.recorder = &MockAuthorizationServerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAuthorizationServer) EXPECT() *MockAuthorizationServerMockRecorder {
	return m.recorder
}

// CheckAuthorization mocks base method.
func (m *MockAuthorizationServer) CheckAuthorization(arg0 context.Context, arg1 *proto.Cookie) (*proto.UserID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CheckAuthorization", arg0, arg1)
	ret0, _ := ret[0].(*proto.UserID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CheckAuthorization indicates an expected call of CheckAuthorization.
func (mr *MockAuthorizationServerMockRecorder) CheckAuthorization(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckAuthorization", reflect.TypeOf((*MockAuthorizationServer)(nil).CheckAuthorization), arg0, arg1)
}

// LogIn mocks base method.
func (m *MockAuthorizationServer) LogIn(arg0 context.Context, arg1 *proto.LogInData) (*proto.Cookie, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LogIn", arg0, arg1)
	ret0, _ := ret[0].(*proto.Cookie)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LogIn indicates an expected call of LogIn.
func (mr *MockAuthorizationServerMockRecorder) LogIn(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LogIn", reflect.TypeOf((*MockAuthorizationServer)(nil).LogIn), arg0, arg1)
}

// LogOut mocks base method.
func (m *MockAuthorizationServer) LogOut(arg0 context.Context, arg1 *proto.Cookie) (*proto.Empty, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LogOut", arg0, arg1)
	ret0, _ := ret[0].(*proto.Empty)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LogOut indicates an expected call of LogOut.
func (mr *MockAuthorizationServerMockRecorder) LogOut(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LogOut", reflect.TypeOf((*MockAuthorizationServer)(nil).LogOut), arg0, arg1)
}

// SignUp mocks base method.
func (m *MockAuthorizationServer) SignUp(arg0 context.Context, arg1 *proto.SignUpData) (*proto.Cookie, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SignUp", arg0, arg1)
	ret0, _ := ret[0].(*proto.Cookie)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SignUp indicates an expected call of SignUp.
func (mr *MockAuthorizationServerMockRecorder) SignUp(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SignUp", reflect.TypeOf((*MockAuthorizationServer)(nil).SignUp), arg0, arg1)
}

// MockUnsafeAuthorizationServer is a mock of UnsafeAuthorizationServer interface.
type MockUnsafeAuthorizationServer struct {
	ctrl     *gomock.Controller
	recorder *MockUnsafeAuthorizationServerMockRecorder
}

// MockUnsafeAuthorizationServerMockRecorder is the mock recorder for MockUnsafeAuthorizationServer.
type MockUnsafeAuthorizationServerMockRecorder struct {
	mock *MockUnsafeAuthorizationServer
}

// NewMockUnsafeAuthorizationServer creates a new mock instance.
func NewMockUnsafeAuthorizationServer(ctrl *gomock.Controller) *MockUnsafeAuthorizationServer {
	mock := &MockUnsafeAuthorizationServer{ctrl: ctrl}
	mock.recorder = &MockUnsafeAuthorizationServerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUnsafeAuthorizationServer) EXPECT() *MockUnsafeAuthorizationServerMockRecorder {
	return m.recorder
}

// mustEmbedUnimplementedAuthorizationServer mocks base method.
func (m *MockUnsafeAuthorizationServer) mustEmbedUnimplementedAuthorizationServer() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "mustEmbedUnimplementedAuthorizationServer")
}

// mustEmbedUnimplementedAuthorizationServer indicates an expected call of mustEmbedUnimplementedAuthorizationServer.
func (mr *MockUnsafeAuthorizationServerMockRecorder) mustEmbedUnimplementedAuthorizationServer() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "mustEmbedUnimplementedAuthorizationServer", reflect.TypeOf((*MockUnsafeAuthorizationServer)(nil).mustEmbedUnimplementedAuthorizationServer))
}
